package main

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"
	"strings"
)

type todo1 struct {
	ID       int    `json:"id"`
	Text     string `json:"text"`
	Complete bool   `json:"complete"`
}

var todos = []todo1{}
var nextID = 1

func handleTodo(w http.ResponseWriter, r *http.Request) {

	w.Header().Set("Content-Type", "application/json")
	switch r.Method {
	case "GET":

		if err := json.NewEncoder(w).Encode(todos); err != nil {
			http.Error(w, "Failed to encode JSON", http.StatusInternalServerError)
			return
		}
	case "POST":

		var newTodo todo1
		if err := json.NewDecoder(r.Body).Decode(&newTodo); err != nil {
			http.Error(w, "Invalid JSON", http.StatusBadRequest)
			return
		}

		newTodo.ID = nextID
		nextID++
		todos = append(todos, newTodo)

		w.WriteHeader(http.StatusCreated)
		if err := json.NewEncoder(w).Encode(newTodo); err != nil {
			http.Error(w, "Failed to encode JSON", http.StatusInternalServerError)
			return
		}

	default:
		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
	}
}

func handleDel(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case "DELETE":

		idStr := strings.TrimPrefix(r.URL.Path, "/todo/del/")
		id, err := strconv.Atoi(idStr)

		if err != nil || id < 1 {
			http.Error(w, "Invalid ID", http.StatusBadRequest)
			return
		}
		fmt.Fprint(w, "Delete Complete!")

		for i, todo := range todos {
			if todo.ID == id {
				todos = append(todos[:i], todos[i+1:]...)
				w.WriteHeader(http.StatusNoContent)
				return
			}
		}

		http.Error(w, "Todo Not Found", http.StatusNotFound)

	default:
		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
	}
}

func handleId(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case "GET":

		idStr := strings.TrimPrefix(r.URL.Path, "/todo/")
		id, err := strconv.Atoi(idStr)

		if err != nil || id < 1 {
			http.Error(w, "Invalid ID", http.StatusBadRequest)
			return
		}

		for _, todo := range todos {
			if todo.ID == id {
				w.Header().Set("Content-Type", "application/json")
				json.NewEncoder(w).Encode(todo)
				return
			}
		}

		http.Error(w, "Todo Not Found", http.StatusNotFound)

	default:
		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
	}
}

func handleUpdate(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case "PUT":

		idStr := strings.TrimPrefix(r.URL.Path, "/todo/update/")
		id, err := strconv.Atoi(idStr)

		if err != nil || id < 1 {
			http.Error(w, "Invalid ID", http.StatusBadRequest)
			return
		}

		for i, todo := range todos {
			if todo.ID == id {
				var updateTodo todo1

				if err := json.NewDecoder(r.Body).Decode(&updateTodo); err != nil {
					http.Error(w, "Invalid JSON", http.StatusBadRequest)
					return
				}

				todos[i].Text = updateTodo.Text
				todos[i].Complete = updateTodo.Complete

				w.WriteHeader(http.StatusOK)
				w.Header().Set("Content-Type", "application/json")
				json.NewEncoder(w).Encode(todos[i])
				fmt.Fprint(w, "Update Complete!")
				return
			}
		}
		http.Error(w, "Todo Not Found", http.StatusNotFound)

	default:
		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
	}
}
